package main

import (
	"context"
	"fmt"
	"log"
	"net/http"
	"os"

	"connectrpc.com/connect"
	"github.com/rs/cors"
	"golang.org/x/net/http2"
	"golang.org/x/net/http2/h2c"

	greetv1 "tyranno/backend/gen/proto" // generated by protoc-gen-go
	"tyranno/backend/gen/proto/greetv1connect"
	// generated by protoc-gen-connect-go
)

type GreetServer struct{}

func (s *GreetServer) Greet(
	ctx context.Context,
	req *connect.Request[greetv1.GreetRequest],
) (*connect.Response[greetv1.GreetResponse], error) {
	log.Println("Request headers: ", req.Header())
	res := connect.NewResponse(&greetv1.GreetResponse{
		Greeting: fmt.Sprintf("Hello, %s!", req.Msg.Name),
	})
	res.Header().Set("Greet-Version", "v1")
	return res, nil
}

func main() {
	os.Exit(run())
}

func run() int {
	greeter := &GreetServer{}
	mux := http.NewServeMux()
	path, handler := greetv1connect.NewGreetServiceHandler(greeter)
	mux.Handle(path, handler)
	http.ListenAndServe(
		"localhost:8080",
		// Use h2c so we can serve HTTP/2 without TLS.
		cors.AllowAll().Handler(h2c.NewHandler(mux, &http2.Server{})),
	)
	const (
		ok = 0
		ng = 1
	)

	// DI
	// logger := log.NewHandler(log.LevelInfo, log.WithJSONFormat())
	// ulidGenerator := ulid.NewUILDGenerator()
	// roomRepository := roomrepository.New()
	// messageRepository := messagerepository.New()
	// chatInteractor := chatinteractor.New(ulidGenerator, roomRepository, messageRepository)
	// healthzServer := healthz.New(logger)
	// chatServer := chat.New(logger, chatInteractor)

	// mux := http.NewServeMux()
	// // mux.Handle(protoconnect.NewHealthzHandler(healthzServer))
	// greeter := &GreetServer{}
	// // mux.Handle(protoconnect.NewChatServiceHandler(chatServer))
	// path, handlera := greetv1connect.NewGreetServiceHandler(greeter)

	// mux.Handle(path, handlera)
	// handler := cors.AllowAll().Handler(h2c.NewHandler(mux, &http2.Server{}))

	// srv := &http.Server{
	// 	Addr:    ":8080",
	// 	Handler: handler,
	// }

	// ctx, cancel := signal.NotifyContext(context.Background(), os.Interrupt, os.Kill)
	// defer cancel()

	// go func() {
	// 	if err := srv.ListenAndServe(); !errors.Is(err, http.ErrServerClosed) {
	// 		log.Fatal(err)

	// 		// logger.ErrorCtx(ctx, "failed to ListenAndServe", "err", err)
	// 	}
	// 	log.Fatal("test")
	// }()

	// <-ctx.Done()

	// timeoutCtx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	// defer cancel()
	// if err := srv.Shutdown(timeoutCtx); err != nil {
	// 	return ng
	// }
	return ok
}
